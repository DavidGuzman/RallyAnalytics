<html><head><title>Analytics 2.0 Lookback API User Manual</title><style type="text/css">ol{margin:0;padding:0}.c19{padding-left:0pt;line-height:1.15;margin-left:104pt}.c5{padding-left:0pt;direction:ltr;margin-left:30pt}.c7{padding-left:0pt;direction:ltr;margin-left:36pt}.c21{list-style-type:disc;margin:0;padding:0}.c29{list-style-type:square;margin:0;padding:0}.c0{list-style-type:circle;margin:0;padding:0}.c18{color:#000099;text-decoration:underline}.c24{padding-left:0pt;margin-left:108pt}.c28{max-width:468pt;padding:72pt 72pt 72pt 72pt}.c3{height:11pt;direction:ltr}.c6{color:#1155cc;text-decoration:underline}.c14{margin:5px;border:1px solid black}.c1{color:inherit;text-decoration:inherit}.c30{padding-top:18pt;padding-bottom:4pt}.c2{margin-right:-72pt;direction:ltr}.c26{padding-left:0pt;margin-left:180pt}.c33{font-size:12pt}.c9{font-weight:bold}.c36{text-indent:36pt}.c11{margin-left:36pt}.c39{margin-left:38pt}.c42{margin-left:137pt}.c8{direction:ltr}.c32{margin-left:144pt}.c15{margin-left:54pt}.c27{padding-left:0pt}.c23{background-color:#d9d9d9}.c20{height:18pt}.c13{margin-left:72pt}.c40{margin-left:71pt}.c31{background-color:#ffff00}.c10{background-color:#e6b8af}.c12{background-color:#ffffff}.c17{color:#222222}.c34{font-size:10pt}.c35{margin-left:68pt}.c37{margin-left:216pt}.c22{margin-left:18pt}.c16{vertical-align:super}.c38{font-size:9pt}.c41{background-color:#cccccc}.c4{font-family:Courier New}.c25{line-height:1.15}.title{padding-top:24pt;line-height:1.0;text-align:left;color:#000000;font-size:36pt;font-family:Arial;font-weight:bold;padding-bottom:6pt}.subtitle{padding-top:18pt;line-height:1.0;text-align:left;color:#666666;font-style:italic;font-size:24pt;font-family:Georgia;padding-bottom:4pt}p{color:#000000;font-size:11pt;margin:0;font-family:Arial}h1{padding-top:12pt;line-height:1.0;text-align:left;color:#000000;font-size:24pt;font-family:Arial;font-weight:bold;padding-bottom:12pt}h2{padding-top:11.2pt;line-height:1.0;text-align:left;color:#000000;font-size:18pt;font-family:Arial;font-weight:bold;padding-bottom:11.2pt}h3{padding-top:12pt;line-height:1.0;text-align:left;color:#000000;font-size:14pt;font-family:Arial;font-weight:bold;padding-bottom:12pt}h4{padding-top:12.8pt;line-height:1.0;text-align:left;color:#000000;font-size:12pt;font-family:Arial;font-weight:bold;padding-bottom:12.8pt}h5{padding-top:12.8pt;line-height:1.0;text-align:left;color:#000000;font-size:9pt;font-family:Arial;font-weight:bold;padding-bottom:12.8pt}h6{padding-top:18pt;line-height:1.0;text-align:left;color:#000000;font-size:8pt;font-family:Arial;font-weight:bold;padding-bottom:18pt}</style></head><body class="c12 c28"><h1 class="c8"><a name="h.sd8kttw9a3gk"></a><span>Analytics 2.0 Lookback API User Manual</span></h1><p class="c8"><span>PREVIEW DOCUMENTATION</span></p><p class="c8"><span class="c6"><a class="c1" href="https://docs.google.com/a/rallydev.com/document/d/1YC9w1XYcsbJdDpV5HbiU-iJdNBnB4TsAKdeHEwDDddw/edit?authkey=COfStNkJ">SOURCE DOCUMENT</a></span><span>&nbsp;(must have a rallydev.com email address to load and edit)</span></p><p class="c3"><span></span></p><h2 class="c8"><a name="h.3uts3l8qqwbj"></a><span>Overview</span></h2><p class="c8"><span class="c9">Single source of record.</span><span>&nbsp;Our vision is for Rally to be the single source of record for your software and systems project data. To see this vision forward, we are constantly striving to improve your ability to make better decisions by gleaming insight from your data. Up until now, it&#39;s been difficult to get time-series data out in a raw form without resorting to taking your own nightly data dumps or parsing the revision history of each individual work item.</span></p><p class="c3"><span></span></p><p class="c8"><span class="c9">First installment of Analytics 2.0.</span><span>&nbsp;This API (code named Lookback API), is the first installment on Rally&#39;s Analytics 2.0 initiative. This A2.0 effort will include interactive charts and visualizations along with user interface support to easily configure them and place them wherever you want, both inside and outside of Rally. However, in the tradition of Agile, we are doing the smallest increment that can deliver value (and provide feedback) soonest,</span></p><p class="c3"><span></span></p><p class="c8"><span class="c9">Go back in time. </span><span>With this API, you will be able to roll back the clock and see what any work item or collection of work items looked like at any moment in time. This is the data that you need to calculate your own time-series charts (burn, cumulative flow, defect trend, etc.). Have you ever wanted your burn chart to be based upon counts of work items? Have you ever wondered how much the burn-up projection would change if you filtered out all of the &quot;nice-to-have&quot; stories? Want your defect trend chart filtered by a custom field? All of these things are now possible.</span></p><p class="c3"><span></span></p><p class="c8"><span class="c9">Advanced temporal visualizations and queries.</span><span>&nbsp;It also opens up a whole new world of advanced visualizations. Imagine showing an animation of your kanban board or showing the iteration status as it looked at 5pm on the last day of the iteration. We can&#39;t wait to see what you dream up. Furthermore, even if you are looking for a particular type of event but don&#39;t know when it occurred, this API can help. You can ask it for all of the instances where a story moved from In-Progress backward to Ranked or any time when a P1 defect was downgraded.</span></p><p class="c3"><span></span></p><p class="c8"><span class="c9">Total dogfooding.</span><span>&nbsp;No longer will we maintain a private data warehouse that we use to generate charts in Rally but give you much more limited access to your own data. This API and the underlying data model are exactly what we are consuming in our own A2.0 development. Also, </span><span>the</span><span>&nbsp;charts that we develop will be available in source code form (like Apps are now) so you can tweak them in ways that we can&#39;t even imagine.</span></p><h2 class="c8 c20"><a name="h.10jt30s03rmw"></a></h2><hr style="page-break-before:always;display:none;"><h2 class="c8 c20"><a name="h.nn1c2z7bqv9h"></a></h2><h2 class="c8"><a name="h.jjz17wnohccz"></a><span>Release status</span></h2><p class="c8"><span>Currently: early-access preview, running in prodution for a sub-set of all subscriptions, connected to live Rally for changes... usually within a few seconds.</span></p><p class="c3"><span></span></p><p class="c8"><span>Anticipated phase of availability is indicated by coloring as follows:</span></p><p class="c3"><span></span></p><p class="c11 c8"><span>Alpha - No coloring</span></p><p class="c11 c8"><span class="c23">Delayed in Preview - There were a few things that are not present 03/2012 (mostly due to Rally WSAPI bug(s)). We are fixing these as they come up.</span></p><p class="c11 c8"><span class="c31">Expected by General Availability - Yellow</span></p><p class="c11 c8"><span class="c10">Later (if ever) - Pink</span></p><h2 class="c8"><a name="h.jdxv1ilp7set"></a><span>TODOS FOR THIS DOCUMENT</span></h2><ol class="c21" start="1"><li class="c7"><span>Fix all JSON so that the keys are in quotes.</span></li></ol><h2 class="c8 c20"><a name="h.sfj4reyfoh5g"></a></h2><hr style="page-break-before:always;display:none;"><h2 class="c8 c20"><a name="h.kfcrowpiwdgs"></a></h2><h2 class="c8"><a name="h.5vnzkya9j7en"></a><span>Table of Contents</span></h2><p class="c8 c22"><span class="c6"><a class="c1" href="#h.sd8kttw9a3gk">Analytics 2.0 Lookback API User Manual</a></span></p><p class="c11 c8"><span class="c6"><a class="c1" href="#h.3uts3l8qqwbj">Overview</a></span></p><p class="c11 c8"><span class="c6"><a class="c1" href="#h.jjz17wnohccz">Release status</a></span></p><p class="c11 c8"><span class="c6"><a class="c1" href="#h.jdxv1ilp7set">TODOS FOR THIS DOCUMENT</a></span></p><p class="c11 c8"><span class="c6"><a class="c1" href="#h.5vnzkya9j7en">Table of Contents</a></span></p><p class="c11 c8"><span class="c6"><a class="c1" href="#h.uv4o9mhshx4">Data model</a></span></p><p class="c11 c8"><span class="c6"><a class="c1" href="#h.c8r1x8rjkf7v">Queries</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.li5umfaav6yi">Find (required)</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.f7fofj2ee6lt">Supported Operators</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.6kkoefoji7na">Operators for date fields</a></span></p><p class="c8 c13"><span class="c6"><a class="c1" href="#h.bk9itr8vican">FormattedID</a></span></p><p class="c8 c13"><span class="c6"><a class="c1" href="#h.wh43g6yaz2ij">String matching against drop-down fields</a></span></p><p class="c8 c13"><span class="c6"><a class="c1" href="#h.cg4fmd9dfwo1">Inequality comparisons against drop down fields</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.v331nz80t2w9">Highly selective criteria</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.ry7lvwi5m6u4">Fields</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.v36pxipjpu4c">Hydrate</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.gyicrotydogj">Start and pagesize</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.sldv3o8446hy">Sort</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.d5pqcdv7cvr8">Response</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.89st9tk50t26">ETLDate</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.e2q07rdwoha1">Additional fields available upon request</a></span></p><p class="c11 c8"><span class="c6"><a class="c1" href="#h.n441voyvm78t">Endpoints</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.vyen79gy48wk">Other endpoints</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.lqiljzz3ez8">Status endpoint</a></span></p><p class="c8 c11"><span class="c6"><a class="c1" href="#h.1tx4m76esrkv">JSONP, CORS and cross-domain queries</a></span></p><p class="c11 c8"><span class="c6"><a class="c1" href="#h.h1533y4a8no">Authentication and authorization</a></span></p><p class="c11 c8"><span class="c6"><a class="c1" href="#h.f9awzacgptuq">Hierarchy</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.212h0tvwwrr0">Project hierarchy</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.74ffd1i09kol">Project scope up</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.tjbhto5yo5fn">Work item hierarchy</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.1ypwxdt5iyhm">Work Item type &quot;hierarchy&quot;</a></span></p><p class="c11 c8"><span class="c6"><a class="c1" href="#h.jd1iqtlbnzot">Scenarios</a></span></p><p class="c8 c13"><span class="c6"><a class="c1" href="#h.i82qvia9s9kn">1. Retrieve the entire history of a particular Rally work item</a></span></p><p class="c8 c13"><span class="c6"><a class="c1" href="#h.pe4snqe5bgl3">2. Retrieve the &quot;current&quot; version of a particular Rally work item</a></span></p><p class="c8 c13"><span class="c6"><a class="c1" href="#h.i82qvia9s9kn">3. Retrieve a particular Rally work item as it looked on a particular date</a></span></p><p class="c8 c13"><span class="c6"><a class="c1" href="#h.kx2q3ej6jprc">4. Retrieve a set of work items as they looked on a particular date</a></span></p><p class="c8 c13"><span class="c6"><a class="c1" href="#h.s9xn61wpnsxb">5. Retrieve defects that experienced a particular state transition in July 2011</a></span></p><p class="c8 c13"><span class="c6"><a class="c1" href="#h.qc8uaiqtq1er">6. Find out how long a work item has been in its current KanbanState</a></span></p><p class="c8 c13"><span class="c6"><a class="c1" href="#h.72v1o7427999">7. Create a Portfolio Item, or Story (epic) burn chart... or cumulative flow chart</a></span></p><p class="c8 c13"><span class="c6"><a class="c1" href="#h.cquetyhsx74x">8. Provide analytics about Defects below some high level Story</a></span></p><p class="c8 c13"><span class="c6"><a class="c1" href="#h.4qtaia3wrxlu">9. Create your own throughput report except use the state transition to Completed instead of Accepted</a></span></p><p class="c11 c8"><span class="c6"><a class="c1" href="#h.rshnkhu87s7f">Query and response details</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.e8zzkoraon8q">Warnings</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.xhk1c8w4b96k">Dates, timestamps, and timezones</a></span></p><p class="c11 c8"><span class="c6"><a class="c1" href="#h.cggucapyj2h8">Paradigm shifts</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.g2knwz9zaeq1">The past is unchangeable</a></span></p><p class="c8 c15"><span class="c6"><a class="c1" href="#h.uq4xsy4nsyg3">A different security model</a></span></p><p class="c11 c8"><span class="c6"><a class="c1" href="#h.lhh5nsm2hzyf">FAQ</a></span></p><h2 class="c8 c20"><a name="h.eipbgglb0mh"></a></h2><h2 class="c8 c20"><a name="h.vwtbnfp01cvy"></a></h2><hr style="page-break-before:always;display:none;"><h2 class="c8 c20"><a name="h.d8ld5cm2t0ih"></a></h2><h2 class="c8"><a name="h.uv4o9mhshx4"></a><span>Data model</span></h2><p class="c8"><span>The data model for the repository that sits under this API has been carefully crafted for efficient analytics. It is particularly well suited to seeing how your data changes over time which is the focus of most reports (burn charts, defect trend, cumulative flow, etc.).&nbsp;</span></p><p class="c3"><span></span></p><p class="c8"><span class="c9">Snapshot schema</span></p><p class="c3"><span class="c9"></span></p><p class="c8"><span>The data is stored in a snapshot schema which means that every time there is a change, an entirely new snapshot of the effected entity is saved with the new values (as well as the old ones). The older snapshot is not removed. It is only updated to adjust its _ValidTo timestamp. </span></p><p class="c3"><span></span></p><p class="c8"><span>Let&#39;s say you have this:</span></p><p class="c3"><span></span></p><p class="c8"><span class="c4">{</span></p><p class="c8"><span class="c4">&nbsp; _id: B2E, &nbsp; &nbsp; &nbsp; // GUID just for analytics engine</span></p><p class="c8"><span class="c4">&nbsp; ObjectID: 777, &nbsp;// objectID (OID) from Rally</span></p><p class="c8"><span class="c4">&nbsp; _UnformattedID: 2345,</span></p><p class="c8"><span class="c4">&nbsp; _Type: [&quot;PersistableObject&quot;, &quot;DomainObject&quot;,</span></p><p class="c11 c8"><span class="c4">&nbsp; &nbsp; &nbsp;&quot;WorkspaceDomainObject&quot;, &quot;Artifact&quot;, &quot;Defect&quot;]</span></p><p class="c8"><span class="c4">&nbsp; Name: &quot;Footer disappears when using new menu&quot;,</span></p><p class="c8"><span class="c4">&nbsp; State: &quot;Submitted&quot;,</span></p><p class="c8"><span class="c4">&nbsp; _ValidFrom: &quot;2011-01-01T12:34:56Z&quot;,</span></p><p class="c8"><span class="c4">&nbsp; _ValidTo: &quot;9999-01-01T00:00:00Z&quot;, &nbsp; &nbsp;// &quot;current&quot; snapshot</span></p><p class="c8"><span class="c4">&nbsp; ... // Other fields not shown</span></p><p class="c8"><span class="c4">}</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span>Then on January 2, 2011, at noon GMT, the analytics engine receives a notice that Rally object 777 had its &quot;</span><span>S</span><span>tate&quot; field changed from &quot;Submitted&quot; to &quot;Open&quot;. The latest record for rally object 777 is read. Its _validTo is updated but nothing else is changed in that record. Rather, a new record is </span><span>created</span><span>&nbsp;showing the new value as well as the previous values for the field</span><span>(s) that changed.</span><span>&nbsp;So, the repository would now contain the updated original plus the new snapshot like so:</span></p><p class="c3"><span></span></p><p class="c8"><span class="c4">{</span></p><p class="c8"><span class="c4">&nbsp; _id: B2E, &nbsp; &nbsp; &nbsp; // GUID just for analytics engine</span></p><p class="c8"><span class="c4">&nbsp; ObjectID: 777, &nbsp;// objectID (OID) from Rally</span></p><p class="c8"><span class="c4">&nbsp; _UnformattedID: 2345,</span></p><p class="c8"><span class="c4">&nbsp; _Type: [&quot;PersistableObject&quot;, &quot;DomainObject&quot;,</span></p><p class="c11 c8"><span class="c4">&nbsp; &nbsp; &nbsp;&quot;WorkspaceDomainObject&quot;, &quot;Artifact&quot;, &quot;Defect&quot;]</span></p><p class="c8"><span class="c4">&nbsp; Name: &quot;Footer disappears when using new menu&quot;,</span></p><p class="c8"><span class="c4">&nbsp; State: &quot;Submitted&quot;,</span></p><p class="c8"><span class="c4">&nbsp; _ValidFrom: &quot;2011-01-01T12:34:56Z&quot;, &nbsp;</span></p><p class="c8"><span class="c9 c4">&nbsp; _ValidTo: &quot;2011-01-02T12:00:00Z&quot;, // updated</span></p><p class="c8"><span class="c4">&nbsp; ... // Other fields not shown</span></p><p class="c8"><span class="c4">}</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span class="c4">{</span></p><p class="c8"><span class="c9 c4">&nbsp; _id: A37, &nbsp; &nbsp; &nbsp; // a new analytics &quot;document&quot; so it gets a new _id</span></p><p class="c8"><span class="c4">&nbsp; ObjectID: 777, &nbsp;// same old Rally OID</span></p><p class="c8"><span class="c4">&nbsp; _UnformattedID: 2345,</span></p><p class="c8"><span class="c4">&nbsp; _Type: [&quot;PersistableObject&quot;, &quot;DomainObject&quot;,</span></p><p class="c11 c8"><span class="c4">&nbsp; &nbsp; &nbsp;&quot;WorkspaceDomainObject&quot;, &quot;Artifact&quot;, &quot;Defect&quot;]</span></p><p class="c8"><span class="c4">&nbsp; Name: &quot;Footer disappears when using new menu&quot;,</span></p><p class="c8"><span class="c9 c4">&nbsp; State: &quot;Open&quot;,</span></p><p class="c8"><span class="c9 c4">&nbsp; _ValidFrom: &quot;2011-01-02:12:00:00Z&quot;, &nbsp;// equals B2E&rsquo;s _ValidTo</span></p><p class="c8"><span class="c4">&nbsp; _ValidTo: &quot;9999-01-01T00:00:00Z&quot;, &nbsp; &nbsp;</span></p><p class="c8"><span class="c9 c4">&nbsp; _PreviousValues: {</span></p><p class="c8"><span class="c9 c4">&nbsp; &nbsp; State: &quot;Submitted&quot;</span></p><p class="c8"><span class="c9 c4">&nbsp; },</span></p><p class="c8"><span class="c4">&nbsp; ... // Other fields not shown</span></p><p class="c8"><span class="c4">}</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span>Things to note:</span></p><ol class="c21" start="1"><li class="c5"><span>Every time there is a change, an entirely new snapshot of the effected entity is saved with the new values (as well as the unchanged ones). &nbsp;Each snapshot is numbered sequentially and identified by the _SnapshotNumber field.</span></li><li class="c5"><span>The _PreviousValues field stores the values that were replaced when this particular snapshot was added.</span></li><li class="c5"><span>The entity type and fields are named according to how they </span><span>are</span><span>&nbsp;named in Rally&#39;s WSAPI.</span></li><li class="c5"><span>Fields that start with an underscore (&quot;_&quot;) are fields that do not exist in Rally&#39;s WSAPI and are provided for the convenience of analytics queries.</span></li><li class="c5"><span>All timestamps are stored in GMT. </span></li><li class="c5"><span>The way _ValidFrom and _ValidTo are manipulated, you can rely upon the property that for a given Rally ObjectID, only one version of the object will be active for any moment in time.</span></li><li class="c5"><span>The examples above are only a subset of all the fields in the document. </span></li><li class="c5"><span>Big text fields and attachments are excluded, but Name is included along with most other fields, including custom fields.</span></li><li class="c5"><span>Null (&lt;No Entry&gt;) values are not stored except...</span></li><li class="c5"><span>There is a special case where a value is changed from null to a non-null value. In this case, the _PreviousValues field will explicitly say that it was null before the change. This null pattern is also followed for all fields that are set when the item is created.</span></li></ol><h2 class="c8"><a name="h.c8r1x8rjkf7v"></a><span>Queries</span></h2><p class="c8"><span>Queries are submitted to the Rally analytics engine, either (1) via POST where the contents have a single well-formed JSON object; or (2) via GET with the same parameters. </span></p><p class="c3"><span></span></p><p class="c8"><span>A query follows this general format:</span></p><p class="c3"><span></span></p><p class="c8"><span class="c4">{</span></p><p class="c8"><span class="c4">&nbsp; </span><span class="c9 c4">find: { &nbsp;// Required</span></p><p class="c8"><span class="c9 c4">&nbsp; &nbsp; // Query clauses</span></p><p class="c8"><span class="c9 c4">&nbsp; },</span></p><p class="c8"><span class="c4">&nbsp; fields: [&quot;State&quot;, &quot;PlanEstimate&quot;], // Field list</span></p><p class="c8"><span class="c4">&nbsp; pagesize: 1000, // default (if omitted) DEFAULT_PAGESIZE</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; // changed to min([MAX_PAGESIZE, &lt;your value&gt;)</span></p><p class="c8"><span class="c4">&nbsp; start: 0, // Specifies at which object it should begin returning</span></p><p class="c8"><span class="c4">&nbsp; sort: {_id: 1},</span></p><p class="c8"><span class="c4">&nbsp; </span><span class="c10 c4">hydrate: {</span></p><p class="c8"><span class="c10 c4">&nbsp; &nbsp; // Hydrate specification</span></p><p class="c8"><span class="c10 c4">&nbsp; }</span></p><p class="c8"><span class="c4">}</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span>or</span></p><p class="c3"><span></span></p><p class="c8"><span class="c4">https://rally.../analytics/1.27/1234/artifact/snapshot/query.js?find={...}</span></p><p class="c3"><span></span></p><p class="c8"><span>where 1.27 is the version of the API and 1234 is the ObjectID of the Workspace.</span></p><h3 class="c8"><a name="h.li5umfaav6yi"></a><span>Find (required)</span></h3><p class="c8"><span>The operators in the query syntax for the analytics APIs are a subset of that offered by MongoDB. We find this to be an elegant syntax that provides a lot of flexibility and low friction with our current implementation, which happens to use MongoDB. You can read about the MongoDB query operators </span><span class="c18"><a class="c1" href="http://www.10gen.com/static/downloads/mongodb_qrc_queries.pdf">here</a></span><span>.</span></p><p class="c3"><span></span></p><h3 class="c8"><a name="h.f7fofj2ee6lt"></a><span>Supported Operators</span></h3><p class="c8"><span>We support the following operator usage:</span></p><p class="c3"><span></span></p><ol class="c21" start="1"><li class="c7"><span class="c4">{a: 10}</span><span>&nbsp;- docs where a is 10 or an array containing the value 10</span></li><li class="c7"><span class="c4">{a: 10, b: &quot;hello&quot;}</span><span>&nbsp;- docs where a is 10 and b is &quot;hello&quot;</span></li><li class="c7"><span class="c4">{a: {$gt: 10}}</span><span>&nbsp;- docs where a &gt; 10, also $lt, $gte, and $lte </span><span class="c4">&nbsp; </span></li><li class="c7"><span class="c4">{a: {$ne: 10}}</span><span>&nbsp;- docs where a != 10</span><span class="c4">&nbsp;</span></li><li class="c7"><span class="c4">{a: {$in: [10, &quot;hello&quot;]}}</span><span>&nbsp;- docs where a is either 10 or &quot;hello&quot;</span></li><li class="c7"><span class="c12 c4">{a: {$exists: true}}</span><span class="c12">&nbsp;- docs containing an &quot;a&quot; field</span></li><li class="c7"><span class="c12 c4">{a: {$exists: false}}</span><span class="c12">&nbsp;- docs not containing an &quot;a&quot; field</span></li><li class="c7"><span class="c12 c4">{a: {$type: 2}}</span><span class="c12">&nbsp;- docs where a is a string (see </span><span class="c12 c18"><a class="c1" href="http://bsonspec.org">bsonspec.org</a></span><span class="c12">&nbsp;for more types)</span></li><li class="c7"><span class="c4">{a: /foo.*bar/}</span><span>&nbsp;- docs where a matches the regular expression &quot;foo.*bar&quot;</span></li><li class="c7"><span class="c4">{&quot;a.b&quot;: 10}</span><span>&nbsp;- docs where a is an embedded document where b is 10</span></li><li class="c7"><span class="c4">{$or: [{a: 1}, {b: 2}]}</span><span>&nbsp;- docs where a is 1 or b is 2</span></li><li class="c7"><span class="c4">{$and: [{a: 1}, {b: 2}]}</span><span>&nbsp;- docs where a is 1 and b is 2</span></li><li class="c7"><span class="c10 c4">{a: {$all: [10, &quot;hello&quot;]}} - NOT SUPPORTED NOW</span></li><li class="c7"><span class="c10 c4">{a: {$mod: [10, 1]}} - NOT SUPPORTED NOW</span></li><li class="c7"><span class="c10 c4">{a: {$size: 3}} - NOT SUPPORTED NOW</span></li><li class="c7"><span class="c10 c4">{a: {$elemMatch: {b: 1, c: 2}} NOT SUPPORTED NOW</span></li></ol><p class="c3"><span class="c12 c4"></span></p><p class="c8"><span>The following operator usage supported by MongoDB is currently supported only as an experiment at this time but may not be supported long-term by this API. Consider them undocumented features. Use them at your own risk. The main problem with $nin is performance. If we can figure out a way to allow its safe usage (throttling?), then we may &quot;document&quot; it. We left it in for now to enable experimentation that will help us discern how valuable it might be.</span></p><p class="c3"><span></span></p><ol class="c21" start="17"><li class="c7"><span class="c10 c4">{a: {$not: {$type: 2}}} - $not is NOT SUPPORTED NOW</span></li><li class="c7"><span class="c10 c4">{a: {$nin: [10, &quot;hello&quot;]}} - $nin is NOT SUPPORTED NOW</span></li></ol><h3 class="c8"><a name="h.6kkoefoji7na"></a><span>Operators for date fields</span></h3><p class="c8"><span class="c12">_ValidFrom and _ValidTo supports the following operators:</span></p><ol class="c21" start="1"><li class="c7"><span class="c12">equals (for example {_ValidFrom: &quot;2011-01-01TZ&quot;})</span></li><li class="c7"><span class="c12">$gt</span></li><li class="c7"><span class="c12">$gte</span></li><li class="c7"><span class="c12">$lt</span></li><li class="c7"><span class="c12">$lte</span></li><li class="c7"><span class="c12">$ne</span></li></ol><p class="c3"><span class="c12"></span></p><p class="c8"><span class="c12">__At only supports equals.</span></p><p class="c3"><span class="c12"></span></p><p class="c8"><span class="c12">In exchange for limited operators on _ValidFrom, _ValidTo and __At, you get full support for </span><span class="c18 c12"><a class="c1" href="http://en.wikipedia.org/wiki/ISO_8601">ISO-8601 date string formats</a></span><span class="c12">&nbsp;including week numbers, day of the year, etc.</span><sup><a href="#cmnt1" name="cmnt_ref1">[a]</a></sup></p><p class="c3"><span class="c12"></span></p><p class="c8"><span class="c12">For other date fields, the API will attempt to parse the canonical forms of ISO-8601 (yyyy-mm-ddTZ, yyyy-mm-ddThh:mm:ssZ, and yyyy-mm-ddThh:mm:ss.lllZ as well as the timeshift equivalents). The API will attempt to apply whatever operators you give it on date fields... whether they make sense or not.</span><sup><a href="#cmnt2" name="cmnt_ref2">[b]</a></sup></p><h4 class="c8"><a name="h.bk9itr8vican"></a><span>FormattedID</span></h4><p class="c8"><span>Rally&#39;s standard WSAPI allows a query clause like </span></p><p class="c3"><span></span></p><p class="c8"><span class="c4">(FormattedID = 2345) // Note the missing &quot;DE&quot;</span></p><p class="c3"><span></span></p><p class="c8"><span>We don&#39;t actually have a FormattedID field in the analytics database. Rather, we keep a field named _UnformattedID. It is the FormattedID without the prefix. You can submit queries like</span></p><p class="c3"><span></span></p><p class="c8"><span class="c4">{_UnformattedID: 2345}</span></p><p class="c3"><span></span></p><p class="c8"><span>However, you can also send queries with a clause on FormattedID. They will simply be converted to two clauses; one on _UnformattedID and the other on _Type. So, it becomes</span></p><p class="c3"><span></span></p><p class="c8"><span class="c4">{_UnformattedID: 2345, _Type: &quot;Defect&quot;}</span></p><p class="c3"><span></span></p><p class="c8 c25"><span>Because of complications associated with the conversion around FormattedID, not all combinations of operators are supported. There is support for: $and, $or, $ne, $in, and $exists with FormattedID, including all recursive combinations of $and and $or. If a complicated query is not behaving as expected try recomposing it with ObjectID instead of FormattedID. Operators we will likely never support on FormattedID include $lt, $lte, $gt, $gte, $all, $mod, $nin, $nor, $type... but they don&#39;t really make sense for this field.</span></p><p class="c3"><span></span></p><h4 class="c8"><a name="h.wh43g6yaz2ij"></a><span>String matching against drop-down fields</span></h4><p class="c8"><span>The allowed values for drop-down fields are specific to the Rally work item type. So the allowed values for the State field for Tasks are different than the State field for Defects. When you submit a query against a drop-down field, it will try to match the provided drop-down value(s) against any type that might have that value. In most cases, this is what you want. So: </span></p><p class="c3"><span></span></p><p class="c8"><span class="c4">{KanbanState: &quot;Accepted&quot;}</span></p><p class="c3"><span></span></p><p class="c8"><span>will match any work item that happens to have a KanbanState field set to &quot;Accepted&quot;.</span></p><p class="c3"><span></span></p><p class="c8"><span>However, if you want to restrict your query to a particular work item type, you can do so by including an &nbsp;_Type clause in your query like:</span></p><p class="c3"><span></span></p><p class="c8"><span class="c4">{_Type: &quot;Defect&quot;, Priority: &quot;High&quot;}</span></p><p class="c3"><span></span></p><h4 class="c8"><a name="h.cg4fmd9dfwo1"></a><span>Inequality comparisons against drop down fields</span></h4><p class="c8"><span>You can also do inequality comparisons against drop-down fields, like this:</span></p><p class="c3"><span></span></p><p class="c11 c8"><span class="c4">{KanbanState: {$lt:&quot;In Progress&quot;}}</span></p><p class="c3"><span></span></p><p class="c8"><span>In the above example, the Lookback API will first find all types that have a KanbanState field and find the ordered list of values for that type. Let&#39;s say you have this:</span></p><p class="c3"><span></span></p><p class="c11 c8"><span>HierarchicalRequirement.KanbanState &isin; [&#39;Ready&#39;, &#39;In Progress&#39;, &#39;Done&#39;]</span></p><p class="c11 c8"><span>Defect.KanbanState &isin; [&#39;Triage&#39;, &#39;Ready&#39;, &#39;In Progress&#39;, &#39;Done&#39;]</span></p><p class="c3 c11"><span></span></p><p class="c8"><span>The Lookback API will expand the above query into the following:</span></p><p class="c3 c11"><span class="c4"></span></p><p class="c11 c8"><span class="c4">{KanbanState: {$in:[null, &quot;Triage&quot;, &quot;Ready&quot;]}</span></p><p class="c3 c11"><span class="c4"></span></p><p class="c8"><span>Notice how &quot;null&quot; is an automatically-added lowest order value. This means that any work item where the the KanbanState field is &quot;&lt;No Entry&gt;&quot; will match the above clause.</span></p><p class="c3"><span></span></p><h3 class="c8"><a name="h.v331nz80t2w9"></a><span>Highly selective criteria</span></h3><p class="c8"><span class="c31">In order to limit the load that any one query will place on the service and to ensure that every query uses a fairly selective index, we are going to place restrictions on queries. For instance, &nbsp;we will allow you to get all versions of a single work item, but we may not allow you to get all versions of every work item in a project. On the other hand, we will allow you to get a single moment-in-time view of all work items in a single project but may restrict deep project hierarchies. Project hierarchy queries may be limited by how many projects they encompass and/or may require that you specify some other criteria like State, Priority, etc. The definition of &quot;highly selective&quot; will be a moving target during the alpha period. [REMOVE ALPHA REFERENCE LATER] Our current plan is to start out with no such restrictions and add the restrictions as use cases are better defined. Also, these restrictions may become more liberal when throttling is implemented.</span></p><p class="c3"><span></span></p><h3 class="c8"><a name="h.ry7lvwi5m6u4"></a><span>Fields</span></h3><p class="c8"><span>If no fields parameter is provided, then only the minimum fields are returned in the response (see Response section below for the list of minimum fields). Note, this behavior is the opposite of MongoDB which will return the full documents by default. </span></p><p class="c3"><span></span></p><p class="c8"><span>If you want all the fields returned send in &quot;true&quot;:</span></p><p class="c3"><span></span></p><p class="c8"><span class="c4">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fields: true &nbsp;</span><span class="c31 c4">// Throttled for non-production use only?</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span>Most commonly, you will provide a list of fields:</span></p><p class="c3"><span></span></p><p class="c11 c8"><span class="c4">fields: [&quot;Name&quot;, &quot;PlanEstimate&quot;]</span></p><p class="c3"><span></span></p><p class="c8"><span>The above will return only Name and PlanEstimate.</span></p><p class="c3"><span></span></p><p class="c8"><span class="c10">We also support MongoDB&#39;s object format for field specifications. This gains us the use of the slice operator to return a particular element in an array value. The most likely usage for this is to get the last element in the _Type array.</span></p><p class="c3"><span class="c10 c4"></span></p><p class="c8"><span class="c10 c4">&nbsp; &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fields:{ObjectID: 1, _Type: {$slice: -1}}</span></p><p class="c3"><span class="c12 c4"></span></p><p class="c8"><span>For an explanation why we didn&#39;t use &quot;fetch&quot; like Rally&#39;s standard web services, see the FAQ.</span></p><h3 class="c8"><a name="h.v36pxipjpu4c"></a><span class="c10">Hydrate</span></h3><p class="c8"><span>By default, this API does not attempt to disambiguate drop-down field values from their native ObjectID integer form into strings. However, you can do this disambiguation on the client by calling our </span><span>allowed values</span><span>&nbsp;endpoint. For example, sending a GET to:</span></p><p class="c3"><span></span></p><p class="c8"><span class="c18 c4"><a class="c1" href="">https://rally1.../webservice/1.26/allowedattributevalue/1234.js</a></span></p><p class="c3"><span class="c18"></span></p><p class="c8"><span>would give you a response that would include the string for the allowed value whose OID is 1234.</span></p><p class="c3"><span></span></p><p class="c8"><span>[I just found out that this doesn&#39;t work for Priority, Severity, ScheduleState, Environment and probably non of the other &quot;standard&quot; drop-down fields. And the custom ones are still strings, so that doesn&#39;t help. We need to figure out how they&#39;ll find it for the others.]</span><sup><a href="#cmnt3" name="cmnt_ref3">[c]</a></sup></p><p class="c3"><span></span></p><p class="c8"><span>Also, by default, the _UnformattedID field does not contain the prefix that&#39;s on the FormattedID.</span></p><p class="c3"><span class="c10"></span></p><p class="c8"><span class="c10">You can specify some fields to be hydrated and others to not be hydrated using the alternate &quot;fields&quot; format. For instance:</span></p><p class="c3"><span class="c10"></span></p><p class="c8"><span class="c10 c4">&nbsp; hydrate: {</span></p><p class="c8"><span class="c10 c4">&nbsp; &nbsp; State: 1,</span></p><p class="c8"><span class="c10 c4">&nbsp; &nbsp; FormattedID: 1</span></p><p class="c8"><span class="c10 c4">&nbsp; }</span></p><p class="c3"><span class="c10 c4"></span></p><p class="c8"><span class="c10">will disambiguate the State field into a string instead of an ObjectID. It will also put the prefix in front of the FormattedID so you&#39;ll get back &quot;DE2345&quot; instead of just &quot;2345&quot;.</span></p><h3 class="c8"><a name="h.gyicrotydogj"></a><span>Start and pagesize</span></h3><p class="c8"><span>These behave as you would expect from Rally&#39;s standard WSAPI parameters of the same name which is also how SQL&#39;s SKIP and LIMIT behave. If you supply no pagesize, it will default to DEFAULT_PAGESIZE, which is a pre-determined, low value. If you supply a value higher than the service&#39;s current MAX_PAGESIZE value, the query will be executed as if you sent MAX_PAGESIZE. </span></p><p class="c3"><span></span></p><p class="c8"><span>Note: the settings for DEFAULT_PAGESIZE and MAX_PAGESIZE are subject to change over time.</span></p><h3 class="c8"><a name="h.sldv3o8446hy"></a><span>Sort</span></h3><p class="c8"><span class="c12">You specify sort using an object whose key is the field you want it sorted by and whose value is &nbsp;either 1 for ascending or -1 for descending. This sorts by the _ValidFrom descending:</span></p><p class="c3"><span class="c12"></span></p><p class="c8"><span class="c12 c4">&nbsp; sort: {_ValidFrom: -1}</span></p><p class="c3"><span class="c10 c4"></span></p><p class="c8"><span class="c10">Sort should use the same index as the query. We may reply with an error if the sort you have chosen is not supported by a valid index.</span></p><p class="c3"><span class="c10"></span></p><h3 class="c8"><a name="h.d5pqcdv7cvr8"></a><span>Response</span></h3><p class="c8"><span>The following is an example of a response to a query where no &quot;fields&quot; parameter is specified:</span></p><p class="c3"><span></span></p><p class="c2"><span class="c4">{</span></p><p class="c2"><span class="c4">&nbsp; _rallyAPIMajor: &quot;1&quot;,</span></p><p class="c2"><span class="c4">&nbsp; _rallyAPIMinor: &quot;26&quot;,</span></p><p class="c2"><span class="c4">&nbsp; Errors: [],</span></p><p class="c2"><span class="c4">&nbsp; Warnings: [],</span></p><p class="c2"><span class="c4">&nbsp; TotalResultCount: 54,</span></p><p class="c2"><span class="c4">&nbsp; StartIndex: 1,</span></p><p class="c2"><span class="c4">&nbsp; PageSize: 5,</span></p><p class="c2"><span class="c4">&nbsp; ETLDate: &quot;2011-10-10T12:34:56.789Z&quot;,</span></p><p class="c2"><span class="c4">&nbsp; Results: [</span></p><p class="c2"><span class="c4">&nbsp; &nbsp; {</span></p><p class="c2"><span class="c4">&nbsp; &nbsp; &nbsp; _id: B2E,</span></p><p class="c2"><span class="c4">&nbsp; &nbsp; &nbsp; ObjectID: 777,</span></p><p class="c2"><span class="c4">&nbsp; &nbsp; &nbsp; _ValidFrom: &quot;2011-01-01T12:34:56Z&quot;,</span></p><p class="c2"><span class="c4">&nbsp; &nbsp; &nbsp; _ValidTo: &quot;9999-01-01T00:00:00Z&quot;,</span></p><p class="c2"><span class="c4">&nbsp; &nbsp; &nbsp; Project: 3456,</span></p><p class="c2"><span class="c4">&nbsp; &nbsp; },</span></p><p class="c2"><span class="c4">&nbsp; &nbsp; ... // Another 4 records</span></p><p class="c2"><span class="c4">&nbsp; ]</span></p><p class="c2"><span class="c4">}</span></p><p class="c3"><span></span></p><p class="c8"><span>Notes:</span></p><ol class="c21" start="1"><li class="c7"><span>The fields shown above are the only fields that are returned when a request is sent without a &quot;fields&quot; parameter.</span></li><li class="c7"><span>The following fields behave identically as they would in the standard Rally WSAPI: _rallyAPIMajor, _rallyAPIMinor, Errors, Warning, TotalResultCount, StartIndex, PageSize, and Results</span></li><li class="c7"><span>The following fields have no equivalent from Rally&#39;s standard WSAPI:</span></li></ol><ol class="c0" start="1"><li class="c8 c27 c13"><span>ETLDate. Indicates how up to date the data in the analytics engine is compared to &quot;live&quot; Rally.</span></li><li class="c8 c13 c27"><span>ObjectID. This is not provided by default in the standard WSAPI but it is from this Analytics API</span></li><li class="c8 c27 c13"><span>_ValidFrom</span></li><li class="c8 c27 c13"><span>_ValidTo</span></li></ol><h3 class="c8"><a name="h.89st9tk50t26"></a><span>ETLDate</span></h3><p class="c8"><span>Comparing the ETLDate timestamp to now will tell you how far behind the analytics engine is from the current time. We have borrowed the &quot;point in time&quot; consistent views concept from </span><span class="c18"><a class="c1" href="http://en.wikipedia.org/wiki/Multiversion_concurrency_control">Multiversion Concurrency Control</a></span><span>&nbsp;(MVCC). It&#39;s an ideal fit for us because of our NoSQL horizontal scaling (meaning no cross-document transactions) architecture... but even more so for this application than others that use NoSQL because we needed to keep the old versions anyway.</span></p><p class="c3"><span></span></p><p class="c8"><span class="c9">Paging with ETLDate.</span><span>&nbsp;To ensure that the data that comes back on pages number 2 thru n, on larger queries, it&#39;s best to include a clause in the queries for the 2</span><span class="c16">nd </span><span>thru n</span><span class="c16">th</span><span>&nbsp;pages that limits the response to items that where _ValidFrom is before or equal to the ETLDate that was returned in the response for the 1</span><span class="c16">st</span><span>&nbsp;page:</span></p><p class="c3"><span></span></p><p class="c36 c8"><span class="c4">{_ValidFrom: {$lte: &lt;ETLDate from 1</span><span class="c4 c16">st </span><span class="c4">page&gt;}}</span></p><p class="c3"><span></span></p><h3 class="c8"><a name="h.e2q07rdwoha1"></a><span>Additional fields available upon request</span></h3><p class="c8"><span>The following fields are also available if specified with the fields parameter:</span></p><ol class="c21" start="1"><li class="c7"><span class="c23">_ref: &quot;https://rally1.../webservice/1.26/defect/777.js&quot;</span></li><li class="c7"><span class="c23">_SnapshotRef: &quot;https://.../query.js?find={_id: B2G}</span></li><li class="c7"><span class="c10">FormattedID. Not available on outgoing until/if we do hydrate, incoming it&#39;s converted to a query on _UnformattedID and _Type</span></li><li class="c7"><span>_UnformattedID (If FormattedID=&quot;DE2345&quot;, then _UnformattedID=2345)</span></li><li class="c7"><span>Revision information</span></li><li class="c7"><span>_Revision. OID of revision record</span></li><li class="c7"><span>_RevisionNumber</span></li><li class="c7"><span>_User. User who made the edit</span></li><li class="c7"><span>_SnapshotNumber</span></li><li class="c7"><span>Name</span></li><li class="c7"><span>Custom string fields</span></li><li class="c7"><span>All foreign key ObjectIDs (Workspace, Iteration, Release, Parent, Requirement, etc.)</span></li><li class="c7"><span>All numeric fields (PlanEstimate, TaskActualTotal, TaskEstimateTotal, etc.)</span></li><li class="c7"><span>All booleans</span></li><li class="c7"><span>All date fields</span></li><li class="c7"><span>Child Collections as lists of foreign key ObjectIDs: Tags, Tasks, Changesets, Defects, Children, Duplicates, Predecessors, Successors</span></li></ol><p class="c8"><span>Missing:</span></p><ol class="c21" start="17"><li class="c7"><span>Big/rich text fields (Description, Notes, etc.)</span></li><li class="c7"><span>TestCases collection on Defects and Stories</span></li></ol><ol class="c21" start="1"><li class="c7"><span>Attachments</span></li><li class="c7"><span>Weblink fields</span></li></ol><h2 class="c8 c25 c30"><a name="h.tm7scbgeydfo"></a><span>Endpoints</span></h2><p class="c8"><span>Example query:</span></p><ol class="c21" start="1"><li class="c7"><span class="c4">https://rally1.rallydev.com/analytics/&lt;version&gt;/&lt;workspaceOID&gt;/artifact/snapshot/query.js?find={&quot;ScheduleState&quot;:&quot;In-Progress&quot;}</span></li></ol><p class="c3"><span></span></p><p class="c8"><span>All of the endpoints start with:</span></p><ol class="c21" start="1"><li class="c7"><span class="c4">rally1.rallydev.com/analytics/&lt;version&gt;/&lt;workspaceOID&gt;/...</span></li></ol><p class="c3"><span></span></p><p class="c8"><span>It&#39;s also possible to use an &#39;x&#39; to get the latest version of the API but we recommend that for application development</span></p><ol class="c21" start="1"><li class="c7"><span class="c4">rally1.rallydev.com/analytics/x/&lt;workspaceOID&gt;/... <br></span></li></ol><p class="c8"><span>The primary query endpoint is :</span></p><ol class="c21" start="1"><li class="c7 c25"><span class="c4">.../artifact/snapshot/query.js?find={&quot;KanbanState&quot;:&quot;Accepted&quot;}</span></li></ol><h3 class="c8"><a name="h.vyen79gy48wk"></a><span>Other endpoints</span></h3><ol class="c21" start="2"><li class="c7"><span class="c4">.../artifact/123456.js<br></span><span>return &nbsp;latest version of artifact with ObjectID 123456 in workspace 1234</span></li></ol><p class="c3"><span class="c4"></span></p><ol class="c21" start="3"><li class="c7"><span class="c4">.../artifact/123456/snapshot.js<br></span><span>return all the snapshots with (_ValidFrom &lt; ETLDate) for ObjectID 123456</span></li></ol><p class="c3"><span class="c4"></span></p><ol class="c21" start="4"><li class="c7"><span class="c4">.../artifact/snapshot/4f7377f2e4b0116409ee56c0.js<br></span><span>return specific snapshot, where &quot;4f7377f2e4b0116409ee56c0&quot; is the snapshot _id</span></li></ol><p class="c3"><span class="c4"></span></p><ol class="c21" start="5"><li class="c7"><span class="c4">.../artifact/123456/snapshot/query.js?find={&quot;KanbanState&quot;:&quot;Accepted&quot;}<br></span><span>do the given query, &nbsp;adding in the criteria ObjectID = 123456</span></li></ol><p class="c3"><span></span></p><ol class="c21" start="6"><li class="c7"><span>Also, all of the above support .json extension.</span></li></ol><h3 class="c8"><a name="h.lqiljzz3ez8"></a><span>Status endpoint</span></h3><p class="c8"><span class="c23">If you hit the service endpoint with a GET and no parameters or with a POST and an empty body, the response will include the current status, base urls, and constants for the service. It will look something like this:</span></p><p class="c3"><span class="c23"></span></p><p class="c8"><span class="c23 c4">{</span></p><p class="c8"><span class="c23 c4">&nbsp; _rallyAPIMajor: &quot;1&quot;,</span></p><p class="c8"><span class="c23 c4">&nbsp; _rallyAPIMinor: &quot;26&quot;,</span></p><p class="c8"><span class="c23 c4">&nbsp; BaseURI: &quot;https://.../analytics/snapshot&quot;,</span></p><p class="c8"><span class="c23 c4">&nbsp; InteractiveHelpURL: &quot;https://.../analytics_help.html&quot;, </span></p><p class="c8"><span class="c23 c4">&nbsp; MAX_PAGESIZE: 1000,</span></p><p class="c8"><span class="c23 c4">&nbsp; DEFAULT_PAGESIZE: 5,</span></p><p class="c8"><span class="c23 c4">&nbsp; ETLDate: &quot;2011-10-10T12:34:56.789Z&quot;</span></p><p class="c8"><span class="c23 c4">}</span></p><p class="c3"><span class="c23"></span></p><p class="c8"><span class="c23">Since they are subject to change, your code should get constants like MAX_PAGESIZE from the service rather than assume some previously used value.</span><sup><a href="#cmnt4" name="cmnt_ref4">[d]</a></sup></p><h2 class="c8"><a name="h.1tx4m76esrkv"></a><span class="c10">JSONP,</span><span>&nbsp;</span><span class="c41">CORS and cross-domain queries</span></h2><p class="c8 c25"><span>Note: JSONP is not supported at this time. There were issues with using it in conjunction with basic authentication. We are exploring possibilities for cross-browser access including</span><span><a class="c1" href="http://enable-cors.org/">&nbsp;</a></span><span class="c6"><a class="c1" href="http://enable-cors.org/">CORS</a></span><span>&nbsp;and additional forms of authentication.</span></p><h2 class="c8"><a name="h.h1533y4a8no"></a><span>Authentication and authorization</span></h2><p class="c8"><span>Basic authentication is supported. Supply the properly encoded username and password in the header of each request.</span></p><p class="c3"><span></span></p><p class="c8"><span>Authorization is a bit different from Rally&#39;s standard web services. If you have read privileges for ALL work items in the response, the query will come back as expected. If you are missing read permission for ANY of of the work items that match your query, NONE will be returned. Rather, you will receive an &quot;unauthorized&quot; response.</span></p><h2 class="c8"><a name="h.f9awzacgptuq"></a><span>Hierarchy</span></h2><p class="c8"><span>There are several different hierarchies that are represented in the documents. </span></p><h3 class="c8"><a name="h.212h0tvwwrr0"></a><span>Project hierarchy</span></h3><p class="c8"><span>The Project hierarchy is also represented as an array starting at a root Project for this Workspace. So if work item 777 is at the bottom of this Project hierarchy:</span></p><ol class="c21" start="1"><li class="c7"><span>Project 7890</span></li></ol><ol class="c0" start="1"><li class="c8 c27 c13"><span>Project 6543</span></li></ol><ol class="c29" start="1"><li class="c24 c8"><span>Project 3456</span></li></ol><ol class="c21" start="1"><li class="c8 c32 c27"><span>Work item 777</span></li></ol><p class="c3"><span class="c4"></span></p><p class="c8"><span>The document for work item 777 would look like this:</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span class="c4">{</span></p><p class="c8"><span class="c4">&nbsp; ObjectID: 777,</span></p><p class="c8"><span class="c4">&nbsp; Project: 3456,</span></p><p class="c8"><span class="c4">&nbsp; _ProjectHierarchy: [7890, 6543, 3456],</span></p><p class="c8"><span class="c4">&nbsp; ...</span></p><p class="c8"><span class="c4">}</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span>To retrieve all work items that are in Project 7890 or any of its child projects, you would simply include this clause in your query:</span></p><p class="c3"><span></span></p><p class="c8"><span>&nbsp; </span><span class="c4">&nbsp; _ProjectHierarchy: 7890</span></p><p class="c3"><span class="c9 c33"></span></p><h3 class="c8"><a name="h.74ffd1i09kol"></a><span>Project scope up</span></h3><p class="c8"><span>If you want to accomplish the equivalent of projectScopeUp, you&#39;ll need to submit two queries:. There are two conditions: (1) projectScopeUp in combination with projectScopeDown; and (2) projectScopeUp WITHOUT projectScopeDown.</span></p><p class="c3"><span></span></p><p class="c8"><span>For the former, you would (a) First, submit the query like above and keep the results as part of your result set. Let&#39;s say we&#39;re going to scopeUp on 3456, you would say:</span></p><p class="c3"><span></span></p><p class="c36 c8"><span class="c4">_ProjectHiearchy: 3456</span></p><p class="c3 c36"><span></span></p><p class="c8"><span>(b) When you get that response, inspect the _ProjectHierarchy field of any of the responses that come back. For all of the values before the one you are interested in (3456 in this example), build another array to pass back into a $in clause (&quot;[7890, 6543]&quot; in this example). Then submit a query like this and add it to the earlier results:</span></p><p class="c3"><span></span></p><p class="c8"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c4">Project: {$in: [7890, 6543]}</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span>For condition (2), you would (a) first submit the same query as 1a above but set the pagesize to 1 (This is favored over simply querying &quot;Project: 3456&quot; because it has a lower chance of hitting the problem in the note below.).</span></p><p class="c3"><span></span></p><p class="c8"><span>(b) You would inspect the results and submit the following:</span></p><p class="c3"><span></span></p><p class="c8"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c4">Project: {$in: [7890, 6543, 3456]}</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span>what comes back is projectScopeUp without projectScopeDown.</span></p><p class="c3"><span></span></p><p class="c8"><span>Note, there is a risk that there are no results from the initial query of &quot;_ProjectHiearchy: 3456&quot;. In that case, this approach will not work.</span></p><h3 class="c8"><a name="h.tjbhto5yo5fn"></a><span>Work item</span><span>&nbsp;hierarchy</span></h3><p class="c8"><span>The work item hierarchy works the same way using the _ItemHierarchy field. So if you have this hierarchy:</span></p><ol class="c21" start="2"><li class="c7"><span>Story 333</span></li></ol><ol class="c0" start="2"><li class="c8 c27 c13"><span>Story 444</span></li></ol><ol class="c29" start="2"><li class="c24 c8"><span>Story 555</span></li></ol><ol class="c21" start="1"><li class="c8 c27 c32"><span>Story 666</span></li></ol><ol class="c0" start="1"><li class="c8 c26"><span>Defect 777</span></li></ol><ol class="c29" start="1"><li class="c8 c27 c37"><span>Task 12</span></li></ol><ol class="c0" start="2"><li class="c26 c8"><span>Task 13</span></li></ol><ol class="c29" start="3"><li class="c24 c8"><span>Story 888</span></li><li class="c24 c8"><span>Story 999</span></li></ol><p class="c3"><span></span></p><p class="c8"><span>The document for Story 666 would look like this:</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span class="c4">{</span></p><p class="c8"><span class="c4">&nbsp; ObjectID: 666,</span></p><p class="c8"><span class="c4">&nbsp; _Type: &quot;HierarchicalRequirement&quot;,</span></p><p class="c8"><span class="c4">&nbsp; Parent: 555,</span></p><p class="c8"><span class="c4">&nbsp; _ItemHierarchy: [333, 444, 555, 666],</span></p><p class="c8"><span class="c4">&nbsp; ...</span></p><p class="c8"><span class="c4">}</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span>To retrieve all Stories that descend from Story 333 (includes 333, 444, 555, 666, 888, and 999 but not Defect 777), you would include this clause in your query:</span></p><p class="c3"><span></span></p><p class="c8"><span class="c4">{</span></p><p class="c8"><span class="c4">&nbsp; _ItemHierarchy: 333,</span></p><p class="c8"><span class="c4">&nbsp; _Type: &quot;HierarchicalRequirement&quot;</span></p><p class="c8"><span class="c4">}</span></p><p class="c3"><span></span></p><p class="c8"><span>Note: Until the _IsLeaf functionality described below is implemented (if ever), you can simulate it with either of these two query clauses: (1) for just Stories:</span></p><p class="c3"><span></span></p><p class="c8"><span class="c4">Children: null</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span>(2) for Stories or Portfolio Items:</span></p><p class="c3"><span></span></p><p class="c8"><span class="c4">$or: [</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; {_Type: &quot;HierarchicalRequirement&quot;, Children: null},</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; {_Type:&quot;PortfolioItem&quot;, Children: null, UserStories: null}</span></p><p class="c8"><span class="c4">]</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span class="c10">Additionally, there is a virtual field named _IsLeaf that is set for all leaf Portfolio Items and Stories (but not Defect, Tasks, etc.). So, this query clause:</span></p><p class="c3"><span class="c10"></span></p><p class="c8"><span class="c10 c4">{</span></p><p class="c8"><span class="c10 c4">&nbsp; _ItemHierarchy: 333,</span></p><p class="c8"><span class="c10 c4">&nbsp; _IsLeaf: true</span></p><p class="c8"><span class="c10 c4">}</span></p><p class="c3"><span class="c10"></span></p><p class="c8"><span class="c10">would match Story 666, Story 888, and Story 999 in the example tree above. Note, that we could exclude the _Type clause because _IsLeaf is only set to true for Stories (and leaf Portfolio Items that have no children Stories, once Portfolio Manager is released).</span></p><p class="c3"><span></span></p><p class="c8"><span>Note that _ItemHierachy will cross work item type boundaries. So the document for Task 12 would look like this:</span></p><p class="c3"><span></span></p><p class="c8"><span class="c4">{</span></p><p class="c8"><span class="c4">&nbsp; ObjectID: 12,</span></p><p class="c8"><span class="c4">&nbsp; _Type: &quot;Task&quot;,</span></p><p class="c8"><span class="c4">&nbsp; Parent: 777,</span></p><p class="c8"><span class="c4">&nbsp; _ItemHierarchy: [333, 444, 555, 666, 777, 12],</span></p><p class="c8"><span class="c4">&nbsp; ...</span></p><p class="c8"><span class="c4">}</span></p><p class="c3"><span></span></p><p class="c8"><span>So, if you wanted all of the Tasks that were descendant from some high level story like Story 333, you could get that with this query clause:</span></p><p class="c3"><span></span></p><p class="c8"><span class="c4">{</span></p><p class="c8"><span class="c4">&nbsp; _ItemHierarchy: 333,</span></p><p class="c8"><span class="c4">&nbsp; _Type: &quot;Task&quot;</span></p><p class="c8"><span class="c4">}</span></p><h3 class="c8"><a name="h.1ypwxdt5iyhm"></a><span>Work Item type &quot;hierarchy&quot;</span></h3><p class="c8"><span>While this may not be as obvious at first, there is also a _Type hierarchy in Rally. A Defect is also an Artifact, is also a WorkspaceDomainObject, etc. We represent this in the analytics database like this.</span></p><p class="c3"><span></span></p><p class="c8"><span>{</span></p><p class="c8"><span class="c4">&nbsp; _Type: [</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; &quot;PersistableObject&quot;,</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; &quot;DomainObject&quot;,</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; &quot;WorkspaceDomainObject&quot;,</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; &quot;Artifact&quot;,</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; &quot;Defect&quot;</span></p><p class="c8"><span class="c4">&nbsp; ],</span></p><p class="c8"><span class="c4">&nbsp; ...</span></p><p class="c8"><span>}</span></p><p class="c3"><span></span></p><p class="c8"><span>The way queries against the analytics engine work, if you include:</span></p><p class="c3"><span></span></p><p class="c8"><span>&nbsp; </span><span class="c4">_Type: &quot;Artifact&quot;</span></p><p class="c3"><span></span></p><p class="c8"><span>as a clause in your query, it will match the _Type field in the example above. There is no need to say &quot;contains&quot; or provide any additional operator for this to match. It knows that if the target value is an array, any element of that array is sufficient for a match.</span></p><p class="c3"><span></span></p><p class="c8"><span>To query for Defects and HierarchicalRequirements:</span></p><p class="c3"><span></span></p><p class="c8"><span class="c4">&nbsp; _Type: {$in: [&quot;Defect&quot;, &quot;HierarchicalRequirement&quot;]}</span></p><h2 class="c8"><a name="h.jd1iqtlbnzot"></a><span>Scenarios</span></h2><p class="c8"><span>The examples below show you how to retrieve data in a variety of </span><span>scenarios.</span></p><h4 class="c8"><a name="h.i82qvia9s9kn"></a><span>1. Retrieve the entire history of a particular Rally work item </span></h4><p class="c8"><span class="c4">{objectID: 777}</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span>You could just as easily have queried on FormattedID.</span></p><p class="c3"><span></span></p><p class="c8"><span>&lt;technical_sidebar&gt;When the data is updated from Rally, there are brief moments when the data in this analytics engine may not be self-consistent. For example, when a high level story is re-parented, the analytics engine needs to adjust the _ItemHierarchy field for all of the descendant stories. Since each story is kept in a separate &quot;document&quot; in the analytics database and the NoSQL technology that we are using does not support cross-document transactions (traditional SQL transactions are traded-off for horizontal scalability), we are using this ETLDate timestamp approach to make sure your queries are self-consistent. Until the long running re-parenting operation is complete, the ETLDate timestamp will continue to point to the last time in the analytics engine where all the changes have trickled across all effected documents.&lt;/technical_sidebar&gt;</span></p><p class="c3"><span></span></p><p class="c8"><span class="c12">Note that for any query that doesn&#39;t already specify a criteria on _ValidFrom, the ETLDate (&quot;current&quot;) timestamp is going to be added. The below query will actually be run:</span></p><p class="c3"><span class="c12 c4"></span></p><p class="c8"><span class="c12 c4">{objectID: 777, _ValidFrom: {$lte: &quot;current&quot;}}</span></p><h4 class="c8"><a name="h.pe4snqe5bgl3"></a><span class="c12">2. </span><span class="c12">Retrieve the &quot;current&quot; version of a particular Rally work item</span></h4><p class="c8"><span class="c12 c4">{objectID:777, __At: &quot;current&quot;} // &quot;__At&quot; has two underscores</span></p><p class="c3"><span class="c12 c4"></span></p><p class="c8"><span class="c12">The &quot;current&quot; will be replaced with the ETLDate timestamp</span><span class="c12">&nbsp;which may be anywhere from a few milliseconds to a few minutes behind transactions in the primary Rally UI.</span></p><p class="c3"><span class="c12"></span></p><p class="c8"><span class="c12">Note that the &quot;__At&quot; field is not actually a field in the analytics engine. It&rsquo;s syntactic sugar equivalent to:</span></p><p class="c3"><span class="c12"></span></p><p class="c8"><span class="c12 c4">{</span></p><p class="c8"><span class="c12 c4">&nbsp; objectID: 777, </span></p><p class="c8"><span class="c12 c4">&nbsp; _ValidFrom: {$lte: &quot;current&quot;}, </span></p><p class="c8"><span class="c12 c4">&nbsp; _ValidTo:{$gt: &quot;current&quot;}</span></p><p class="c8"><span class="c12 c4">}</span></p><p class="c3"><span class="c12"></span></p><p class="c8"><span class="c12">You should feel free to explicitly use _ValidTo and _ValidFrom depending upon your needs.</span></p><h4 class="c8"><a name="h.i82qvia9s9kn"></a><span class="c12">3. </span><span class="c12">Retrieve a particular Rally work item as it looked on a particular date</span></h4><p class="c8"><span class="c12 c4">{FormattedID: &quot;DE2345&quot;, __At:&quot;2011-01-10T00:00:00Z&quot;}</span></p><p class="c3"><span></span></p><p class="c8"><span>The date in the example above is midnight on January 9, 2011 in the Zulu timezone. It is preferable to specify the following day &quot;2011-01-10T00:00:00Z&quot; than to use 24:00:00 on the day in question, but &quot;2011-01-09T24:00:00:00Z&quot; is equivalent. </span></p><p class="c3"><span></span></p><p class="c8"><span>Further, it is permissible to exclude the lower order elements when they are zero. So, you could have written &quot;2011-01-10T00Z&quot;.</span></p><p class="c3"><span class="c12"></span></p><p class="c8"><span class="c12">Also, note that we used the &quot;FormattedID&quot; field instead of the ObjectID for this example. In the example below, we omit the &quot;DE&quot; prefix. The FormattedID is actually stored without the &quot;DE&quot; in the _UnformattedID field and it is stripped from queries so the below example is equivalent.</span></p><p class="c3"><span class="c12"></span></p><p class="c8"><span class="c12 c4">{</span></p><p class="c8"><span class="c12 c4">&nbsp; _UnformattedID:&quot;2345&quot;, </span></p><p class="c8"><span class="c12 c4">&nbsp; _Type: &quot;Defect&quot;, </span></p><p class="c8"><span class="c12 c4">&nbsp; __At: &quot;2011-01-10T00:00:00Z&quot;</span></p><p class="c8"><span class="c12 c4">}</span></p><p class="c3"><span class="c12 c4"></span></p><p class="c8"><span class="c12">Note, the above translation example works well when a single FormattedID is specified. However, it&#39;s less obvious how it would work if multiple kinds of artifacts were specified. For instance, how would it behave if it recieved this:</span></p><p class="c3"><span class="c12"></span></p><p class="c8"><span class="c12 c4">&nbsp; FormattedID: {$in[&quot;DE2345&quot;, &quot;S1234&quot;]} </span></p><p class="c3"><span class="c12"></span></p><p class="c8"><span class="c12">The above example $in clause is supported by in the API because it automatically converts it to an appropriate $or clause. $exists, equals &quot;:&quot; are supported in this circumstance but other operators may not be supported. </span><span>If you have need to compose a complicated query, it is best to use ObjectID rather than FormattedID. There is limited support for: $and, $or, $ne, $in, and $exists with FormattedID, although not all recursive combinations of $and and $or will work. Operators not supported include $lt, $lte, $gt, $gte, $all, $mod, $nin, $nor, $type.</span></p><h4 class="c8"><a name="h.kx2q3ej6jprc"></a><span>4. </span><span>Retrieve a set of work items as they looked on a particular date</span></h4><p class="c8"><span class="c4">{</span></p><p class="c8"><span class="c4">&nbsp; _ProjectHierarchy: 7890, </span></p><p class="c8"><span class="c4">&nbsp; _Type: &quot;Defect&quot;,</span></p><p class="c8"><span class="c4">&nbsp; Priority: &quot;High Attention&quot;,</span></p><p class="c8"><span class="c4">&nbsp; __At:&quot;2011-02-01</span><span class="c4">T00Z</span><span class="c4">&quot;</span></p><p class="c8"><span class="c4">}</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span>The above query will return the list of defects in Project 7890 and its sub-projects that had the their Priority field set to &quot;High Attention&quot; as of the end of January, 2011. Notice how the __At field is set to February 1. Our own charts will follow the convention of using 00:00:00.000 of the first day of the following month when trying to identify the state as of the end of a particular month. We will search for entities whose _ValidFrom and _ValidTo dates are &quot;&lt;&quot; and &quot;&gt;=&quot;, respectively to the provided timestamp.</span></p><h4 class="c8"><a name="h.s9xn61wpnsxb"></a><span>5. Retrieve defects that experienced a particular state transition in July 2011</span></h4><p class="c8"><span class="c4">{</span></p><p class="c8"><span class="c4">&nbsp; _Type: &quot;Defect&quot;,</span></p><p class="c8"><span class="c4">&nbsp; Project: 7890, </span></p><p class="c8"><span class="c4">&nbsp; &quot;_PreviousValues.KanbanState&quot;: {$lt: &quot;Completed&quot;},</span></p><p class="c8"><span class="c4">&nbsp; KanbanState: {$gte: &quot;Completed&quot;},</span></p><p class="c8"><span class="c4">&nbsp; _ValidFrom: {</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; $gte: &quot;2011-07-01TZ&quot;,</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; $lt: &quot;2011-08-01TZ&quot;</span></p><p class="c8"><span class="c4">&nbsp; }</span></p><p class="c8"><span class="c4">}</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span>Because the analytics database doesn&rsquo;t know anything about ordering of the AllowedValues for the State field, it will look up your AllowedValues for the State field and convert the above query to something like:</span></p><p class="c3"><span></span></p><p class="c8"><span class="c4">{</span></p><p class="c8"><span class="c4">&nbsp; _Type: &quot;Defect&quot;,</span></p><p class="c8"><span class="c4">&nbsp; Project: 7890, </span></p><p class="c8"><span class="c9 c4">&nbsp; &quot;_PreviousValues.KanbanState&quot;: {$in: [null, &quot;Idea&quot;, &quot;Defined&quot;]},</span></p><p class="c8"><span class="c9 c4">&nbsp; KanbanState: {$in: [&quot;Completed&quot;, &quot;Accepted&quot;, &quot;Released&quot;]},</span></p><p class="c8"><span class="c4">&nbsp; _ValidFrom: {</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; $gte: &quot;2011-07-01TZ&quot;,</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; $lt: &quot;2011-08-01TZ&quot;</span></p><p class="c8"><span class="c4">&nbsp; }</span></p><p class="c8"><span class="c4">}</span></p><p class="c3"><span class="c9"></span></p><p class="c8"><span>The State field is &quot;required&quot; (not-nullable) in Rally but the null value is considered the lowest value in the ordered list of AllowedValues so it is included in every such query regardless of the current &quot;required&quot; setting for this field. The thinking is that you may have recently set the field to &quot;required&quot; meaning that there might be some old snapshots where the value is missing. This approach handles all cases as expected. Note, that </span><span class="c18"><a class="c1" href="http://www.mongodb.org/display/DOCS/Querying+and+nulls">MongoDB handles this as expected.</a></span></p><h4 class="c8"><a name="h.qc8uaiqtq1er"></a><span>6. </span><span>Find out how long a work item has been in its current KanbanState</span></h4><p class="c8"><span class="c4">{</span></p><p class="c8"><span class="c4">&nbsp; find: {</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; ObjectID: 777,</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; KanbanState: &lt;current KanbanState&gt;, </span></p><p class="c8"><span class="c4">&nbsp; &nbsp; &quot;_PreviousValues.KanbanState&quot;: {$ne: &lt;current KanbanState&gt;}</span></p><p class="c8"><span class="c4">&nbsp; },</span></p><p class="c8"><span class="c4">&nbsp; </span><span class="c12 c4">sort:</span><span class="c4">&nbsp;{_ValidFrom: -1},</span></p><p class="c8"><span class="c4">&nbsp; pagesize: 1</span></p><p class="c8"><span class="c4">}</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span>This will return the snapshot of the most recent time that ObjectID 777 had transitioned into its current KanbanState. This assumes you have previously retrieved the latest version of ObjectID 777 and know its current KanbanState. The _ValidFrom field in the record that is returned is the timestamp of when it entered the current KanbanState. You simply subtract that from today() to find out how many day&#39;s it has been in this KanbanState.</span></p><p class="c3"><span></span></p><p class="c8"><span>If you batched up a list of work items, you could replace the ObjectID caluse with:</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span class="c4">&nbsp; &nbsp;ObjectID: {$in:[&lt;your list of ObjectIDs&gt;]}</span></p><p class="c3"><span></span></p><p class="c8"><span>and get them all back at once. However, you&#39;d have to drop the sort and limit clauses and figure out on the client which one was the last one for each work item. You decide which is better for your situation.</span></p><h4 class="c8"><a name="h.72v1o7427999"></a><span>7. Create a Portfolio Item, or Story (epic) burn chart... or cumulative flow chart</span></h4><p class="c8"><span>If you have this:</span></p><ol class="c21" start="1"><li class="c7"><span>Portfolio Item 333</span></li></ol><ol class="c0" start="1"><li class="c8 c27 c13"><span>Story 444</span></li></ol><ol class="c29" start="1"><li class="c24 c8"><span>Story 555</span></li></ol><ol class="c21" start="1"><li class="c8 c32 c27"><span>Story 666</span></li></ol><ol class="c0" start="1"><li class="c26 c8"><span>Defect 777 (via the Requirement field)</span></li></ol><ol class="c29" start="1"><li class="c8 c27 c37"><span>Task 12</span></li></ol><ol class="c0" start="2"><li class="c26 c8"><span>Task 13</span></li></ol><ol class="c29" start="2"><li class="c8 c24"><span>Story 888</span></li><li class="c24 c8"><span>Story 999</span></li></ol><p class="c3"><span></span></p><p class="c8"><span>To get all leaf stories that descend from PI 333 (666, 888, and 999) on a particular date and get the PlanEstimate, and ScheduleState fields on January 1:</span></p><p class="c3"><span></span></p><p class="c8"><span class="c4">{</span></p><p class="c8"><span class="c4">&nbsp; find: {</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; _ItemHierarchy: 333,</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; $or[</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; &nbsp; &nbsp; {_Type: &quot;HierarchicalRequirement&quot;, Children: null},</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; &nbsp; &nbsp; {_Type: &quot;PortfolioItem&quot;, Children: null, UserStories: null}</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; ],</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; </span><span class="c10 c4">// Later use &quot;_IsLeaf: true&quot; instead of above &quot;$or&quot; clause</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; __At: &quot;2011-01-01T00:00:00.000Z&quot;</span></p><p class="c8"><span class="c4">&nbsp; },</span></p><p class="c8"><span class="c4">&nbsp; fields: [&quot;PlanEstimate&quot;, &quot;ScheduleState&quot;]</span></p><p class="c8"><span class="c4">}</span></p><p class="c3"><span></span></p><p class="c8"><span>You would then vary the __At clause value to get the other points for the chart.</span></p><p class="c3"><span></span></p><h4 class="c8"><a name="h.cquetyhsx74x"></a><span>8. Provide analytics about Defects below some high level Story</span></h4><p class="c8"><span>&quot;From the EMC... A strong interest was expressed in rolling up defect information by feature ie. for defects linked to a set of stories which roll up to epics and to features provide some analysis at the epic level about those defects.&quot;</span></p><p class="c3"><span></span></p><p class="c8"><span class="c12 c17">So, if you have this:</span></p><p class="c3 c25"><span class="c12 c17"></span></p><ol class="c21" start="1"><li class="c8 c27 c25 c39"><span class="c12 c17">Story 555</span></li></ol><ol class="c0" start="1"><li class="c8 c27 c25 c40"><span class="c12 c17">Story 666</span></li></ol><ol class="c29" start="1"><li class="c8 c19"><span class="c12 c17">Defect 777 (via the Requirement field)</span></li></ol><ol class="c21" start="1"><li class="c8 c27 c25 c42"><span class="c12 c17">Task 12</span></li></ol><ol class="c29" start="2"><li class="c19 c8"><span class="c12 c17">Defect 000</span></li><li class="c19 c8"><span class="c12 c17">Task 13</span></li></ol><ol class="c0" start="2"><li class="c8 c27 c25 c35"><span class="c12 c17">Story 888</span></li></ol><ol class="c29" start="1"><li class="c19 c8"><span class="c12 c17">Defect 999</span></li></ol><p class="c3 c25"><span class="c12 c17"></span></p><p class="c8"><span class="c12 c17">and you have a query clause like this</span></p><p class="c3"><span class="c12 c17"></span></p><p class="c8"><span class="c12 c17 c4">&nbsp; _ItemHierarchy: 555</span></p><p class="c3"><span class="c12 c4 c17"></span></p><p class="c8"><span class="c12 c17">it will match Story 555, Story 666, Defect 777, Task 12, Defect 000, Task 13, Story 888, and Defect 999. Adding a restriction on _Type will get you just the Defects. So, for EMC&#39;s scenario, you want just Defect 777, Defect 000, and Defect 999:</span></p><p class="c3"><span class="c12 c17"></span></p><p class="c8"><span class="c12 c17 c4">{</span></p><p class="c8"><span class="c12 c17 c4">&nbsp; _ItemHierarchy: 555,</span></p><p class="c8"><span class="c12 c17 c4">&nbsp; _Type: &quot;Defect&quot;</span></p><p class="c8"><span class="c12 c17 c4">}</span></p><p class="c3"><span></span></p><h4 class="c8"><a name="h.4qtaia3wrxlu"></a><span>9</span><span>. </span><span>Create your own throughput report except use the state transition to Completed instead of Accepted</span></h4><p class="c8"><span>You can see from scenario 5 how to sense when a particular state transition occurs. You can expand on this to build your own throughput report and control what boundary is counted. The example below keys off of the &quot;State&quot; field but it could just as easily have keyed off of a custom field like &quot;KanbanState&quot;.</span></p><p class="c3"><span></span></p><p class="c8"><span class="c4">{</span></p><p class="c8"><span class="c4">&nbsp; find: {</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; _ProjectHierarchy: 7890,</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; State: {$gte: &quot;Completed&quot;},</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; _PreviousValues.State: {$lt: &quot;Completed&quot;},</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; _ValidFrom: {</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; &nbsp; $gte: &lt;first day of some month&gt;,</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; &nbsp; $lt: &lt;first day of next month&gt;</span></p><p class="c8"><span class="c4">&nbsp; &nbsp; }</span></p><p class="c8"><span class="c4">&nbsp; },</span></p><p class="c8"><span class="c4">&nbsp; pagesize: 0</span></p><p class="c8"><span class="c4">}</span></p><p class="c3"><span class="c4"></span></p><p class="c8"><span>Because we set the pagesize to zero, the response would not contain any of the actual work items but the header information for the response would contain the count needed for this Throughput metric in the TotalResultCount field. </span><span class="c10">We will eventually add metrics like sum and sum of squares to allow you to calculate other metrics. </span><span>For now, if you want more than the count, you&#39;ll need to do that math on the client. </span></p><p class="c3"><span></span></p><p class="c8"><span>You would then iterate, the &lt;...month&gt; literals until you had the data you needed. </span></p><h2 class="c8"><a name="h.rshnkhu87s7f"></a><span>Query and response details</span></h2><p class="c8"><span>You should keep the following in mind when working with this API:</span></p><ol class="c21" start="1"><li class="c5"><span class="c12">The API is JSON-only. No XML </span><span class="c31">although we may do that later and there may be an option to get it in csv format also.</span></li><li class="c5"><span class="c12">The API is REST(-ish) only. There is no SOAP interface. We say REST-ish, because you can use POSTs against this API as an alternative to GETs and the reference-following mechanism recommended (</span><span class="c18 c12"><a class="c1" href="http://en.wikipedia.org/wiki/HATEOAS">HATEOAS</a></span><span class="c12">) in Roy Fielding foundational dissertation on REST are not completely followed by this API.</span></li><li class="c5"><span class="c10">The versioning of this API will be kept in sync with Rally&#39;s other web services APIs. If you are using version 1.26 of Rally&#39;s other API(s), you can also expect to be able to use version 1.26 of this API.</span></li><li class="c5"><span>However, we may make backward-compatible changes to this this API without incrementing the version number. For example, the </span><span class="c9">addition</span><span>&nbsp;of query functionality to this API would not require a version increment. However, removing or changing the syntax for some functionality would require a revision. Because there is no WSDL to change in a REST API as there would be in a SOAP API, this less strict approach should be acceptable for maintaining backward compatibility.</span></li></ol><h3 class="c8"><a name="h.e8zzkoraon8q"></a><span>Warnings</span></h3><ol class="c21" start="1"><li class="c5"><span>[REMOVE ONCE WE LEAVE ALPHA] It is an alpha API. We WILL change it on you without incrementing the version. We will tightly control who is using the API during this alpha period and make sure to give users advance notice before any potentially backward breaking changes are made.</span></li><li class="c5"><span>[MODIFY AS WE ADD SUPPORT FOR OTHER ENTITIES AND REMOVE ONCE WE LEAVE ALPHA] This API is focused on Hierarchical requirements (User Stories), Defects, TestCases, and Tasks for now. The API may actually give you access to other entities, but for these other entities, you should have lower expectations of stability (such as it is anyway in an Alpha API), and documentation as well as indexes and denormalization for efficient querying. Portfolio Items are included and participate correctly in the _ItemHierarchy but the _Type field is not reliable at this time.</span></li></ol><h3 class="c8"><a name="h.xhk1c8w4b96k"></a><span>Dates, timestamps, and timezones</span></h3><p class="c8"><span>All date and time are stored in the analytics database in GMT and communicated to/from using ISO-8601 format using the following possible notations:</span></p><ol class="c21" start="1"><li class="c7"><span>&quot;2011-02-01T00:00:00.000Z&quot; - &quot;Z&quot; means &quot;zulu&quot; time or GMT.</span></li><li class="c7"><span>&quot;2011-02-01T00:00:00Z&quot; - You can omit the milliseconds with &quot;Z&quot; form as well as the forms below. In fact, you can omit all of the lower order values that you want to be zero. &quot;2011-02-01T00Z&quot; is equivalent. [Question: Can you leave off all of the zeros like &quot;2011-02-01TZ&quot;? Does this make parsing to figure out when to add the user&#39;s time zone harder like &quot;2011-02-01T&quot;?]</span></li></ol><ol class="c21" start="1"><li class="c7"><span>&quot;2011-02-01T00:00:00-05:30&quot; To specify a timezone shift in ISO format, use the shift time (e.g. &quot;-05:30&quot;) in place of &quot;Z&quot;. </span></li></ol><h2 class="c8"><a name="h.cggucapyj2h8"></a><span>Paradigm shifts</span></h2><h3 class="c8"><a name="h.g2knwz9zaeq1"></a><span>The past is unchangeable</span></h3><p class="c8"><span>We want to encourage you to think of the past as unchangeable. This is not as obvious as it sounds and it&#39;s actually a departure from the way some of our current reports work. This is best explained with an example. Let&#39;s say you want to trend the count of all open P1 defects within in a particular project over time. One way to do this would be to first find all P1 defects that are currently in that project and then look at the history of each of those defects to find when they were open and resolved. Using this approach, any defects that had moved into the project during the time of interest would would be included in ALL of the data points on the trend line and any that had moved out of the project at an earlier date would be counted in NONE of the points. Similarly, if they didn&#39;t start out as P1s or were downgraded from P1 priority later, that wouldn&#39;t matter. By first finding the defects that are NOW in the project and NOW have P1 priority, you have essentially changed the past.</span></p><p class="c3"><span></span></p><p class="c8"><span>Rather, we want you to think of the generation of this defect trend line as the application of the same query at particular moments in the past. So, if you want to trend by month starting three months ago, you run the query against the data as it looked three months ago, and then you run it again against the data as it looked two months ago, and then finally against the way it looked at the most recent month boundary. If a defect was assigned to your project three months ago but isn&#39;t now, it will be included in the count back then but excluded from this month&#39;s count.</span></p><p class="c3"><span></span></p><p class="c8"><span>The reason for this design choice is simple, by taking this approach, we can warehouse the aggregations from any queries that you run for fast retrieval the next time they are run. It also turns out that this is usually the preferred behavior. We decided to trade-off the ability to perform the alternative type queries for those rare cases where it is preferable in exchange for a huge speed and simplicity advantage for the common case.</span></p><h3 class="c8"><a name="h.uq4xsy4nsyg3"></a><span>A different security model</span></h3><p class="c8"><span class="c9">The current Rally security model is based upon pre-identifying the projects for which you currently have permission BEFORE it even knows what data satisfies your request.</span><span>&nbsp;Once you are authenticated and your current project scope is set, we then know all of the projects within the project scope for which you currently have permission. This list of permissible projects is pre-populated upon each request and it becomes a part of any queries that are submitted to the database (&quot;... WHERE project IN [039284, 039284, 093923]...&quot; for example). This works great for processing the typical read and edit transactions that you do in Rally every day, but it&#39;s not ideal for analytics. Under the current model, it&#39;s possible for two users to request the exact same report but to get back different results because they have different permissions. Worse, the current analytics engine has no way to warn users of this because, under the current security model, it has no way to know it&#39;s missing some data. The &quot;WHERE projects IN ...&quot; clause is automatically added to every query made by the current analytics engine.</span></p><p class="c3"><span></span></p><p class="c8"><span>We wanted to fix this, so </span><span class="c9">the new analytics security model doesn&#39;t check your permissions until AFTER it has figured out what data matches your query. </span><span>Every restricted entity (includes User Stories, Defects, and Tasks) in the new analytics repository has a project field. After a query against these entities is complete, it will extract the set of projects mentioned in the returned entities and compare it to the list of projects for which you have permission. If you have permission for all of them, no worries. If you are missing read permission for one or more, the request will return with an error listing the projects for which you do not have permission. [MAYBE THIS NEEDS TO BE A SETTING. SOME FOLKS MIGHT NOT LIKE US SENDING BACK A LIST OF UNPERMITTED PROJECT NAMES. HOWEVER, I WOULD LIKE TO MAKE IT A WORKSPACE SETTING AND HAVE IT BE ENABLED BY DEFAULT BECAUSE I THINK IT IS MUCH MORE USABLE TO TELL THEM WHICH ONES THEY NEED TO GET ADDED.]</span></p><p class="c3"><span></span></p><p class="c8"><span>Note, that this new security model interacts with the &quot;past is unchangeable&quot; concept. The list of projects will include projects that were pointed to by past versions of work items even if those past projects have been deprecated and contain no work at this time.</span></p><p class="c3"><span class="c9"></span></p><h2 class="c8"><a name="h.lhh5nsm2hzyf"></a><span>FAQ</span></h2><p class="c3"><span class="c9"></span></p><p class="c8"><span class="c9">Q: </span><span class="c9">Is this how things are actually stored?</span></p><p class="c8"><span class="c9">A: </span><span>Pretty much. We&#39;re trying to avoid impedance mismatch between tables and objects. We&#39;re trying to make it fast, clean, and simple.</span></p><p class="c3"><span class="c9"></span></p><p class="c8"><span class="c9">Q: </span><span class="c9">Why </span><span class="c9">is the API so close to the native </span><span class="c9">MongoDB interface?</span></p><p class="c8"><span class="c9">A: </span><span>We like it. In fact, we had an earlier design that was based upon another analytics oriented database technology (CouchDB) and for that design we were still borrowing the MongoDB syntax. </span></p><p class="c3"><span></span></p><p class="c8"><span>There are all sorts of derivatives of SQL (JQL, MDX, TSQL, etc.). The next phase of evolution for web applications, will see an explostion of JSON-based query languages. With MongoDB&#39;s popularity, we wouldn&#39;t be surprised if others built upon it. </span></p><p class="c3"><span></span></p><p class="c8"><span>Note that the API is not blindly passing along whatever you give it. We convert your find clauses into objects; validate and modify them; and then build a query for MongoDB. If we ever have to go away from MongoDB, we will re-implement the query language and translate it to whatever technology is chosen.</span></p><p class="c3"><span class="c9"></span></p><p class="c8"><span class="c9">Q: Why does this API use &quot;fields&quot; rather than &quot;fetch&quot; like Rally&#39;s standard web services API?</span></p><p class="c8"><span class="c9">A: </span><span>We might be convinced otherwise if there is an uproar over this difference, however, we felt that the semantics for &quot;fetch&quot; are overloaded. It both hydrated the sub-objects as well as specified what fields to return. We wanted to make those two things separate. </span></p><div><p class="c8"><span>&copy; </span><span>Rally Software</span></p></div><div class="c14"><p class="c8"><a href="#cmnt_ref1" name="cmnt1">[a]</a><span>lmaccherone:</span></p><p class="c8"><span>Is this true. We need TCR tests to demonstrate which formats are supported.</span></p></div><div class="c14"><p class="c8"><a href="#cmnt_ref2" name="cmnt2">[b]</a><span>lmaccherone:</span></p><p class="c8"><span>Should also confirm this with TCR tests.</span></p></div><div class="c14"><p class="c8"><a href="#cmnt_ref3" name="cmnt3">[c]</a><span>lmaccherone:</span></p><p class="c8"><span>This doesn&#39;t help at all since custom values are strings.</span></p></div><div class="c14"><p class="c8"><a href="#cmnt_ref4" name="cmnt4">[d]</a><span>lmaccherone:</span></p><p class="c8"><span>Does this exist yet?</span></p></div></body></html>